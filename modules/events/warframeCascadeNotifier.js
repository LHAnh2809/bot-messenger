const axios = require('axios');
const fs = require('fs-extra');
const moment = require('moment-timezone');

module.exports.config = {
    name: "warframeCascadeNotifier",
    eventType: [],
    version: "1.0.0",
    credits: "LHAnh",
    description: "T·ª± ƒë·ªông th√¥ng b√°o Warframe Void Cascade missions"
};

// C·∫•u h√¨nh
const API_URL = "https://api.warframestat.us/pc/fissures";
const NOTIFICATION_FILE = "./modules/data/warframe_cascade.json";
const LOG_FILE = "./modules/data/warframe_cascade_log.json";
const CHECK_INTERVAL = 60000; // 60 gi√¢y
const TIMEZONE = "Asia/Ho_Chi_Minh";

// Ghi log v√†o cache
const writeLog = async (message, type = "info") => {
    try {
        await fs.ensureFile(LOG_FILE);

        let logs = [];
        try {
            const logData = await fs.readFile(LOG_FILE, 'utf-8');
            if (logData) {
                logs = JSON.parse(logData);
            }
        } catch (error) {
            // File ch∆∞a t·ªìn t·∫°i ho·∫∑c l·ªói parse
        }

        const logEntry = {
            timestamp: moment().tz(TIMEZONE).format('YYYY-MM-DD HH:mm:ss'),
            type: type,
            message: message
        };

        logs.push(logEntry);

        // Gi·ªØ l·∫°i ch·ªâ 100 log g·∫ßn nh·∫•t
        if (logs.length > 100) {
            logs = logs.slice(-100);
        }

        await fs.writeFile(LOG_FILE, JSON.stringify(logs, null, 2));
    } catch (error) {
        console.error("Error writing log:", error);
    }
};

// Parse th·ªùi gian c√≤n l·∫°i t·ª´ string ETA th√†nh milliseconds
const parseEtaToMs = (etaString) => {
    if (!etaString) return 0;

    const parts = etaString.toLowerCase().match(/(\d+)\s*([smhd])/g);
    if (!parts) return 0;

    let totalMs = 0;
    for (const part of parts) {
        const match = part.match(/(\d+)\s*([smhd])/);
        if (match) {
            const value = parseInt(match[1]);
            const unit = match[2];

            switch (unit) {
                case 's': totalMs += value * 1000; break;
                case 'm': totalMs += value * 60 * 1000; break;
                case 'h': totalMs += value * 60 * 60 * 1000; break;
                case 'd': totalMs += value * 24 * 60 * 60 * 1000; break;
            }
        }
    }
    return totalMs;
};

// Load config ƒë·ªÉ l·∫•y BOX_ID
const loadConfig = () => {
    try {
        const configData = fs.readFileSync('./config.json', 'utf-8');
        const config = JSON.parse(configData);
        return config.BOX_ID || [];
    } catch (error) {
        console.error("Error loading config for BOX_ID:", error);
        return [];
    }
};

// Kh·ªüi t·∫°o file data
const initDataFile = async () => {
    try {
        await fs.ensureFile(NOTIFICATION_FILE);
        const data = await fs.readFile(NOTIFICATION_FILE, 'utf-8');
        if (!data) {
            const defaultData = {
                lastNotifiedMissions: [],
                enabled: true,
                lastCheck: null,
                nextCheckTime: null // Th·ªùi gian check ti·∫øp theo (dynamic interval)
            };
            await fs.writeFile(NOTIFICATION_FILE, JSON.stringify(defaultData, null, 2));
        }
    } catch (error) {
        console.error("Error initializing warframe cascade file:", error);
    }
};

// ƒê·ªçc d·ªØ li·ªáu
const getData = async () => {
    try {
        const data = await fs.readFile(NOTIFICATION_FILE, 'utf-8');
        return JSON.parse(data);
    } catch (error) {
        console.error("Error reading warframe cascade data:", error);
        return { lastNotifiedMissions: [], enabled: true, lastCheck: null, nextCheckTime: null };
    }
};

// L∆∞u d·ªØ li·ªáu
const saveData = async (data) => {
    try {
        await fs.writeFile(NOTIFICATION_FILE, JSON.stringify(data, null, 2));
    } catch (error) {
        console.error("Error saving warframe cascade data:", error);
    }
};

// G·ªçi API Warframe
const fetchFissures = async () => {
    try {
        const response = await axios.get(API_URL, {
            timeout: 10000,
            headers: {
                'User-Agent': 'Warframe-Bot/1.0'
            }
        });
        return response.data;
    } catch (error) {
        console.error("Error fetching Warframe fissures:", error.message);
        return [];
    }
};

// L·ªçc Void Cascade missions
const filterCascadeMissions = (fissures) => {
    return fissures.filter(mission =>
        mission.missionType === "Void Cascade" &&
        mission.isHard === true &&
        mission.active === true &&
        mission.expired === false
    );
};

// Format th√¥ng b√°o
const formatNotification = (missions) => {
    if (missions.length === 0) return null;

    let message = "üî• C·∫¢NH B√ÅO VOID CASCADE WARFRAME üî•\n\n";

    missions.forEach((mission, index) => {
        message += `   üìç ${mission.node}\n`;
        message += `   üéØ Nhi·ªám v·ª•: ${mission.missionType}\n`;
        message += `   ‚öîÔ∏è K·∫ª th√π: ${mission.enemy}\n`;
        message += `   ‚è∞ Th·ªùi gian c√≤n l·∫°i: ${mission.eta}\n`;
        message += `   üîπ Steel Path: ${mission.isSteelPath ? '‚ùå' : '‚úî'}\n`;
    });

    message += "‚ö° H√†nh ƒë·ªông nhanh, Tenno! Nh·ªØng nhi·ªám v·ª• n√†y s·∫Ω kh√¥ng t·ªìn t·∫°i l√¢u!";
    return message;
};

// Ki·ªÉm tra v√† g·ª≠i th√¥ng b√°o
const checkAndNotify = async (api) => {
    try {
        const data = await getData();
        if (!data.enabled) return;

        // Ki·ªÉm tra xem ƒë√£ ƒë·∫øn th·ªùi gian check ch∆∞a
        const now = Date.now();
        if (data.nextCheckTime && now < data.nextCheckTime) {
            const remainingTime = Math.ceil((data.nextCheckTime - now) / 1000);
            await writeLog(`ƒêang ch·ªù ${remainingTime}s tr∆∞·ªõc khi check Void Cascade ti·∫øp theo`, "waiting");
            return;
        }

        // G·ªçi API
        const fissures = await fetchFissures();
        if (!fissures || fissures.length === 0) {
            await writeLog("Check API ‚úì Kh√¥ng c√≥ d·ªØ li·ªáu fissures", "check");
            return;
        }

        // L·ªçc Void Cascade missions
        const cascadeMissions = filterCascadeMissions(fissures);

        if (cascadeMissions.length === 0) {
            await writeLog("Check API ‚úì Kh√¥ng c√≥ Void Cascade", "check");
        } else {
            await writeLog(`Check API ‚úì T√¨m th·∫•y ${cascadeMissions.length} Void Cascade`, "found");
        }

        // Ki·ªÉm tra mission m·ªõi (ch∆∞a th√¥ng b√°o) tr∆∞·ªõc khi t√≠nh delay
        const newMissions = cascadeMissions.filter(mission =>
            !data.lastNotifiedMissions.includes(mission.id)
        );

        // N·∫øu c√≥ mission m·ªõi, g·ª≠i th√¥ng b√°o
        if (newMissions.length > 0) {
            // Format v√† g·ª≠i th√¥ng b√°o
            const notificationMessage = formatNotification(newMissions);
            if (notificationMessage) {
                await writeLog(`T√¨m th·∫•y ${newMissions.length} nhi·ªám v·ª• Void Cascade m·ªõi`, "new_mission");

                // L·∫•y danh s√°ch nh√≥m t·ª´ BOX_ID trong config
                const configBoxes = loadConfig();
                if (configBoxes.length > 0) {
                    await writeLog(`G·ª≠i th√¥ng b√°o üì¢ ƒë·∫øn ${configBoxes.length} nh√≥m (BOX_ID t·ª´ config)`, "notify");
                    for (const threadID of configBoxes) {
                        try {
                            await api.sendMessage(notificationMessage, threadID);
                            await writeLog(`Th√¥ng b√°o ƒë√£ g·ª≠i ƒë·∫øn nh√≥m: ${threadID}`, "sent");
                            await new Promise(resolve => setTimeout(resolve, 2000));
                        } catch (error) {
                            await writeLog(`L·ªói g·ª≠i ƒë·∫øn nh√≥m ${threadID}: ${error.message}`, "error");
                        }
                    }
                } else {
                    await writeLog("Kh√¥ng c√≥ BOX_ID n√†o trong config ƒë·ªÉ g·ª≠i th√¥ng b√°o Void Cascade", "warning");
                }

                // C·∫≠p nh·∫≠t danh s√°ch ƒë√£ th√¥ng b√°o
                data.lastNotifiedMissions = [
                    ...data.lastNotifiedMissions,
                    ...newMissions.map(mission => mission.id)
                ];
                // Gi·ªØ l·∫°i ch·ªâ 50 mission g·∫ßn nh·∫•t
                if (data.lastNotifiedMissions.length > 50) {
                    data.lastNotifiedMissions = data.lastNotifiedMissions.slice(-50);
                }
            }
        }

        // N·∫øu c√≥ Void Cascade missions ƒëang active, t√≠nh delay cho l·∫ßn check ti·∫øp theo
        if (cascadeMissions.length > 0) {
            // T√≠nh th·ªùi gian ch·ªù = th·ªùi gian c√≤n l·∫°i c·ªßa mission ng·∫Øn nh·∫•t + 60s
            const shortestEta = Math.min(...cascadeMissions.map(mission => parseEtaToMs(mission.eta)));
            const nextCheckDelay = shortestEta + 60000; // +60 gi√¢y

            data.nextCheckTime = now + nextCheckDelay;

            const nextCheckMinutes = Math.ceil(nextCheckDelay / 60000);
            const nextCheckTime = moment(data.nextCheckTime).tz(TIMEZONE).format('HH:mm');
            await writeLog(`T√≠nh delay: ETA + 60s = ${nextCheckMinutes}m | Ng·ª´ng check, ch·ªù ƒë·∫øn ${nextCheckTime}`, "delay");
        } else {
            // Reset nextCheckTime khi kh√¥ng c√≤n Void Cascade
            if (data.nextCheckTime) {
                data.nextCheckTime = null;
                await writeLog("Kh√¥ng c√≤n Void Cascade, Resume check b√¨nh th∆∞·ªùng ‚úì", "resume");
            }
        }

        data.lastCheck = moment().tz(TIMEZONE).format();
        await saveData(data);

    } catch (error) {
        await writeLog(`L·ªói trong Warframe cascade check: ${error.message}`, "error");
    }
};

// Global timer
let cascadeTimer = null;

module.exports.onLoad = async function (api) {
    await initDataFile();

    // Clear existing timer
    if (cascadeTimer) {
        clearInterval(cascadeTimer);
    }

    // Set up timer ƒë·ªÉ check m·ªói 60 gi√¢y
    cascadeTimer = setInterval(() => {
        checkAndNotify(api);
    }, CHECK_INTERVAL);

    console.log("H·ªá th·ªëng th√¥ng b√°o Warframe Void Cascade ƒë√£ t·∫£i! Ki·ªÉm tra m·ªói 60 gi√¢y...");

    // Load config v√† hi·ªÉn th·ªã BOX_ID
    const configBoxes = loadConfig();
    if (configBoxes.length > 0) {
        await writeLog(`BOX_ID ƒë∆∞·ª£c t√¨m th·∫•y trong config: ${configBoxes.join(', ')}`, "init");
    } else {
        await writeLog("Kh√¥ng t√¨m th·∫•y BOX_ID trong config.json", "init");
    }

    // Ch·∫°y l·∫ßn ƒë·∫ßu ngay l·∫≠p t·ª©c
    setTimeout(() => {
        checkAndNotify(api);
    }, 5000);
};

module.exports.run = async function ({ api, event, args }) {
    // Command handler cho vi·ªác config (n·∫øu c·∫ßn)
    if (args[0] === "test") {
        const fissures = await fetchFissures();
        const cascades = filterCascadeMissions(fissures);

        if (cascades.length > 0) {
            const message = formatNotification(cascades);
            api.sendMessage(message || "Kh√¥ng t√¨m th·∫•y nhi·ªám v·ª• Void Cascade!", event.threadID, event.messageID);
        } else {
            api.sendMessage("‚ùå Kh√¥ng t√¨m th·∫•y nhi·ªám v·ª• Void Cascade ƒëang ho·∫°t ƒë·ªông!", event.threadID, event.messageID);
        }
    }
};